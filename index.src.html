<pre class='metadata'>
Title: Origin Policy Manifest
Status: DREAM
ED: https://mikewest.github.io/origin-policy-manifest/
Shortname: origin-policy
Level: None
Editor: Mike West 56384, Google Inc., mkwst@google.com
Abstract:
  This specification defines a delivery mechanism for a number of policies
  which are to be applied to an entire origin. It compliments header-based
  delivery mechanisms for existing policies (Content Security Policy,
  Referrer Policy, etc).
Indent: 2
Markup Shorthands: markdown on
Boilerplate: omit conformance, omit feedback-header
</pre>
<pre class="link-defaults">
spec:html; type:element; text:link
</pre>
<pre class="anchors">
spec: FETCH; urlPrefix: https://fetch.spec.whatwg.org/
  type: dfn
    text: CORS-preflight request
</pre>

Introduction {#intro}
=====================

[Insert clever introduction here.]

Examples {#examples}
--------------------

<div class="example">
MegaCorp, Inc. wishes to ensure that a baseline content security policy is
applied to each of the pages on `https://example.com`, while avoiding the
overhead associated with large response headers, and the uncertainty that
they've really covered everything that lives on the origin.

When they see a request come in that contains a <a>`Origin-Policy`</a>
header, they can respond in kind, pointing the client to a manifest file
in a well-known location on their server. That is, given the following
request:

<pre>
GET / HTTP/1.1
Host: example.com
Connection: keep-alive
...
<a>Origin-Policy</a>: 0
...
</pre>

MegaCorp, Inc. can respond with:

<pre>
HTTP/1.1 200 OK
Content-Encoding: gzip
Accept-Ranges: bytes
Cache-Control: max-age=604800
Content-Type: text/html
...
<a>Origin-Policy</a>: "v1"
...
</pre>

The client will parse the response headers, and synchronously request
`https://example.com/.well-known/origin-policy/v1` before completing
the navigation. The policies contained in that file will be cached
according to the normal HTTP caching rules, and applied to pages on
`https://example.com/` (including the current navigation).

<pre>
{
  "<a>csp</a>": [
    {
      "policy": "script-src 'self' https://cdn.example.com; object-src 'none'",
      "mode": "enforce",
      "type": "fallback"
    },
    {
      "policy": "script-src https:; report-to 'mixed'",
      "mode": "report",
      "type": "baseline"
    }
  ],
  "<a>referrer</a>": "origin-when-cross-origin",
  "<a>cors</a>": { "allow-credentials": true },
  "<a>nosniff</a>": true,
  "<a>hsts</a>": true,
}
</pre>

Subsequent requests from the same client will contain the version of
the policy currently cached for the origin. In this case:

<pre>
GET / HTTP/1.1
Host: example.com
Connection: keep-alive
...
<a>Origin-Policy</a>: "<strong>v1</strong>"
...
</pre>

ISSUE: Maybe turn this into a `Link` header with special behavior?
</div>

<pre class="example">
[Add an HTTP/2 server push example to speed this up.]
</pre>

Framework {#framework}
======================

The `Origin-Policy` HTTP Header Field {#origin-policy-header}
-----------------------------------------------------------------

The <dfn export>`Origin-Policy`</dfn> HTTP header field is sent with
navigational HTTP requests in order to advertise support generally for the
origin policy manifest mechanism defined in this document, and to inform
the server which version of its origin policy is cached locally.

The same header is sent by the server in responses to such requests to
inform the client that a origin policy manifest is available to fetch.

<pre class="abnf">
  Origin-Policy: 0 / DQUOTE *( DIGIT / ALPHA / "_" / "-" ) DQUOTE 
</pre>

This header MUST be ignored if delivered over non-secure transport.

User agents have a <dfn export>Origin Policy Store</dfn>, which is a key
value store which can hold a single <dfn>policy</dfn> for each origin.
Each <a>policy</a> is a (<dfn for="policy">version</dfn>,
<dfn for="policy">manifest</dfn>) tuple.

The Origin Policy Manifest File {#manifest-file}
------------------------------------------------------

The <dfn export local-lt="manifest">Origin Policy Manifest</dfn> is a
JSON-formatted document consisting of a top-level object with one or more
members. Each member defines a specific aspect of an origin's policy.

<pre class="example">
{
  "<a>csp</a>": [
    {
      "policy": "script-src 'self' https://cdn.example.com; object-src 'none'",
      "mode": "enforce",
      "type": "fallback"
    },
    {
      "policy": "script-src https:; report-to 'mixed'",
      "mode": "report",
      "type": "baseline"
    }
  ],
  "<a>referrer</a>": "origin-when-cross-origin",
  "<a>cors</a>": { "allow-credentials": true },
  "<a>nosniff</a>": true,
  "<a>hsts</a>": true,
}
</pre>

ISSUE: Perhaps the various members should be pushed out into various other
specs in some kind of extension model. That is, the parsing algorithm could
have a hook for the member name that other specs could latch onto. Not sure
if that's worth the effort, but it might be a more rational way to define
behavior, since we're otherwise hooking into a different spec for each bit.

### The `csp` member {#csp-member}

The <dfn export>`csp`</dfn> member defines a set of <a>Content Security
Policies</a> [[!CSP3]] which will be applied to every resource delivered from the
manifest's origin.

Its value MUST be either a single dictionary, or a list of dictionaries. Each
dictionary MUST have a "`policy`" member, and MAY have "`mode`" and "`type`"
members.

:   <dfn export for="csp">policy</dfn>
::  The CSP to be applied.
:   <dfn export for="csp">mode</dfn>
::  "`enforce`" or "`report`". If not specified, "`enforce`".
:   <dfn export for="csp">type</dfn>
::  "`baseline`" or "`fallback`". If the former, the given `policy` will be
    applied to every resource on an origin. If the latter, the given `policy`
    will be applied only to the resources on an origin that don't themselves
    deliver a `Content-Security-Policy` or `Content-Security-Policy-Report-Only`
    header (as appropriate for the `mode`).

Any non-conforming value will be ignored.

### The `referrer` member {#referrer-member}

The <dfn export>`referrer`</dfn> member defines a <a>Referrer Policy</a>
[[!REFERRER-POLICY]] which will be applied to every resource delivered from
the policy's origin.

Its value MUST be a string. Any other type will be ignored.

### The `cors-preflight` member {#cors-preflight-member}

The <dfn export>`cors`</dfn> member asserts that an origin understands the
CORS protocol, and that the user agent can therefore assume success for certain
types of <a>CORS-preflight requests</a>.

Note: This member does <em>not</em> set defaults for responses in general; it
only allows the user agent to skip the `OPTIONS` preflight request for a
defined set of requests.

Its value MUST be a dictionary. Any other type will be ignored.

#### Values {#cors-preflight-values}

ISSUE: Spell this out.

<pre class="example">
  {
    "cors-preflight": {
      "allow-credentials": true,
      "allow-headers": [ "x-application-specific-header" ],
      "allow-origin": [ "https://not-example.com/" ]
    }
  }
</pre>

ISSUE: This might be a footgun?

### The `hsts` member {#hsts-member}

The <dfn export>`hsts`</dfn> member asserts Strict Transport Security for an
origin [[!RFC6797]].

### The `hpkp` member {#hpkp-member}

The <dfn export>`hpkp`</dfn> member asserts a set of pinned public keys for an
origin [[!RFC7469]].

### The `nosniff` member {#nosniff-member}

The <dfn export>`nosniff`</dfn> member asserts that resources served from an
origin should rely only on their explicitly asserted `Content-Type`, and MUST
not be sniffed into other types of content based on their contents.


HTML Integration {#monkey-patching-html}
----------------

At the end of the navigation algorithm, we'll do the following:

1.  If we have a policy for the origin to which we've navigated (or we're inheriting the
    origin for an `about:blank` or `about:srcdoc` (or if we're Firefox, `data:...`),
    then we apply the policy to the document as defined in [[#apply-policy]] (which
    I haven't written yet.

At the end of the "run a worker" algorithm, we'll do the same thing.

ISSUE: Spell all of this out.

Algorithms {#algorithms}
==========

<h3 algorithm dfn id="version-for-origin">
  Retrieve |origin|'s manifest version.
</h3>

Given an origin (|origin|), this algorithm returns `0` if no manifest is present
in the user agent's <a>Origin Policy Store</a>, or a string representing the
cached version otherwise.

1.  Let |version| be `0`.

2.  If the user agent's <a>Origin Policy Store</a> contains a tuple for
    |origin|, let |version| be that tuple's first element.

3.  Return |version|.

Fetch Integration {#monkey-patching-fetch}
-----------------

During a navigation request, Fetch will hook into this specification in two ways:

1.  At the top of the basic fetch algorithm, Fetch will call
    [[#fetch-prepare-request]] in order to append `Origin-Policy` to the
    request's header list with a value of `0` if no manifest is cached for its
    URL's origin, or a value of the verion of the manifest that is cached  (e.g.
    `"v1"`).

2.  When a response is received during HTTP-network fetch algorithm, Fetch will
    call into [[#fetch-parse-response]] to sift through its headers, and
    extract the `Origin-Policy` header. If present, and its value does not match
    the value of the locally cached manifest for the response's origin, we'll issue
    a synchronous request for a resource located on the request's URL's origin at
    `/.well-known/origin-policy/{value}`, as defined in [[#fetch-manifest]].

    ISSUE: Should we allow service workers to intercept/set policy? Maybe only if they
    are scoped to the whole origin?

<h4 algorithm dfn id="fetch-prepare-request">
  Prepare |request| with Origin Policy.
</h4>

Given a request |request|, add appropriate headers to inform a server about a
client's active policy:

1.  If |request| is not a navigation request, or if  abort these steps and return.

2.  Let |version| be the result of executing [[#version-for-origin]] on
    |request|'s URL's origin.

3.  Append a header named `Origin-Policy` with a value of |version| to
    |request|'s header list.

<h4 algorithm dfn id="fetch-parse-response">
  Process |response| for Origin Policy.  
</h4>

1.  Let |version| be the result of parsing "`Origin-Policy`" in |response|'s
    header list.

2.  If |version| is not `null`, execute [[#fetch-manifest]] on |version| and
    |response|'s URL's origin.

<h4 algorithm dfn id="fetch-manifest">
  Fetch an Origin Policy manifest |version| for |origin|.
</h4>

To fetch a origin policy manifest given a string (|version|) and an origin
(|origin|) execute the following steps:

1.  If |origin| is an opaque origin, abort these steps and return.

2.  Let |url| be the result of executing the <a>URL parser</a> on |origin|'s
    serialization.

3.  If |url| is failure, or [[secure-contexts#is-url-trustworthy]] returns
    "`Not Trustworthy`" when executed upon |url|, abort these steps and return.

4.  Set |url|'s path to the concatenation of "`/.well-known/origin-policy/`" and
    |version|.

5.  Let |request| be a new request whose method is "`GET`", url is |url|, client
    is `null`, window is `no-window`, skip-service-worker flag is set,
    destination is `manifest`, mode is `same-origin`, and redirect mode is
    `error`.

6.  Let |response| be the result of performing an HTTP-network-or-cache fetch 
    using |request|.

7.  If |response|'s status is an ok status:

    1.  Let |MIME type| be the result of extracting a MIME type from
        |response|'s header list.

    2.  If |MIME type| is not `application/manifest+json`, abort these steps
        and return.

    3.  Store the tuple (|version|, |response|'s body) in the user agent's
        <a>Origin Policy Store</a> for |origin|.


Specification Considerations {#specification}
=============================

Fallback vs Baseline {#fallback-vs-baseline}
--------------------

Perhaps this ought to be defined at a higher level of the manifest? It seems
like it might be a useful concept for things other than CSP.

Relation to Web App Manifests {#app-manifest}
-----------------------------

It might make sense to combine this mechanism with the manifest notion
defined in [[APPMANIFEST]]. There are a few distinctions, however, which
lead to the current design:

1.  The =Security Policy Manifest= is delivered synchronously during navigation,
    which gives it a number of valuable security properties. The web app
    manifest, on the other hand, is delivered inline via a <{link}> element,
    which makes it less valuable from that perspective.

2.  Web app manifests can live anywhere on an origin, and anywhere on any other
    origin, for that matter. This might make sense for the feature set it wishes
    to expose, but it would expose an origin to unnecessary risk to be quite so
    loose with =security policy manifest= files.

Nevertheless, we should consider ways to merge this policy with [[APPMANIFEST]].
Perhaps if a certain set of attributes was parsed iff certain properties of the
request are true (same-origin, specific path, etc). Something to look into. For
now, we've done the simple thing as a strawman.
    

Privacy and Security Considerations {#privacy-and-security}
===================================

Tracking {#tracking}
--------

The <a>`Origin-Policy`</a> header, as well as the manifest it represents, can
be used to track users with only marginally less granularity and coverage than
cookies allow. As such, the user agent MUST purge cached manifests whenever a
user instructs it to clear cookies or cached data.

Performance {#perf}
-----------

Servers SHOULD set a long cache lifetime for the manifest file, using the version
to change policy for an origin as opposed to changing the existing policy and
relying on cache expiration.

IANA Considerations {#iana}
===================

ISSUE: Register the header.

ISSUE: Register the well-known path.
