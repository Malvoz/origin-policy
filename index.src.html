<pre class='metadata'>
Title: Origin Policy
Status: DREAM
ED: https://mikewest.github.io/origin-policy/
Shortname: origin-policy
Level: None
Editor: Mike West 56384, Google Inc., mkwst@google.com
Abstract:
  This specification defines a delivery mechanism for a number of policies
  which are to be applied to an entire origin. It compliments header-based
  delivery mechanisms for existing policies (Content Security Policy,
  Referrer Policy, etc).
Indent: 2
Markup Shorthands: markdown on
Boilerplate: omit conformance, omit feedback-header
</pre>
<pre class="link-defaults">
spec:html; type:element; text:link
</pre>
<pre class="anchors">
spec: CSP3; urlPrefix: https://w3c.github.io/webappsec-csp/
  type: dfn
    text: Content Security Policy
spec: HTML; urlPrefix: https://html.spec.whatwg.org/
  type: dfn
    text: origin; url: concept-origin
spec: RFC7540; urlPrefix: https://tools.ietf.org/html/rfc7540
  type: dfn
    text: server push; url: section-8.2
<!--
   -   WHATWG
   -->
spec: FETCH; urlPrefix: https://fetch.spec.whatwg.org/
  type: dfn
    text: CORS-preflight request
    text: header list; url: concept-header-list
    text: parsing; for: header list; url: concept-header-parse
    for: response
      text: header list; url: concept-response-header-list
      text: CSP list; url: concept-response-csp-list
spec: URL; urlPrefix: https://url.spec.whatwg.org/
  type: dfn
    text: URL parser; url: concept-url-parser
<!--
   -   ABNF
   -->
type: grammar
  text: base64-value; url: https://w3c.github.io/webappsec-csp/#grammardef-base64-value; spec: CSP3
  text: DQUOTE; url: https://tools.ietf.org/html/rfc5234#appendix-B.1; spec: RFC5234
</pre>
<pre class="biblio">
{
  "SITE-WIDE-HEADERS": {
      "href": "https://mnot.github.io/I-D/site-wide-headers/",
      "title": "Site-Wide HTTP Headers",
      "authors": [ "Mark Nottingham" ]
  }
}
</pre>

Introduction {#intro}
=====================

Developers set a number of properties associated with resources on an origin
by delivering resource-specific HTTP response headers and <{meta}> elements.
This is becoming more common over time, and it's quite normal these days to see
multiple kilobytes at the beginning of every response dedicated to such
metadata. Setting this metadata is valuable indeed, as it can have a large
impact on performance, security, and privacy.

However, the existing delivery mechanism is ill-suited to the task, suffering
from a clear mismatch between the resource-specific nature of the metadata
declarations on the one hand, and the origin-wide intent of the metadata on the
other. Take `Strict-Transport-Security` [[RFC6797]] and `Public-Key-Pins`
[[RFC7469]], for example. These headers explicitly alters the state of an entire
Moreover, many headers are deployed in such a way as to be practically static
across all resources that an origin serves. `Content-Security-Policy` [[CSP3]],
for instance, can be very granular indeed, but is commonly implemented by
setting a single policy which is delivered for an entire application.

A number of implications follow:

1.  Servers are required to repeat themselves. At length.
    `Content-Security-Policy` alone can easily eat multiple kilobytes of each
    navigational response, bandwidth which could instead be dedicated to content
    a user might care about. This has obvious and direct impact on the delay a
    user experiences when navigating, but has less obvious knock-on effects that
    reduce performance further. HTTP/2's HPACK [[RFC7541]] header compression
    is limited to ~4k of state for processing, for instance, meaning that these
    verbose headers can greatly reduce its effectiveness

2.  Servers are required to repeat themselves. Unerringly. When policy applies
    strictly to a resource, and not to the origin, then a server must send that
    policy down with every response. If the developer forgets a page (which is
    actually a very common occurance: when's the last time you thought about
    your 404 error page? How about your 417? Or 505?), then the policy's
    protections don't apply to that resource, leaving an exploitable hole.

This document introduces a new delivery mechanism for policies which are meant
to apply to an entire origin. In short, a server will provide an <a>Origin
Policy Manifest</a> file at a well-known location. This file contains all of the
metadata the server would like to set for each response. User agents can be
instructed to synchronously download and process this manifest before completing
a navigation to an origin's resources, ensuring that the policy contained therin
will be safely applied to each resource, and allowing the server to skip the
overhead of including the relevant headers with each response. Typically, the
server can speed things up even more by using HTTP/2 Server Push ([[RFC7540]],
section 8.2) to proactively send the manifest file along with the response to
the user agent's first request.

Examples {#examples}
--------------------

<div class="example">
MegaCorp, Inc. wishes to ensure that a baseline content security policy is
applied to each of the pages on `https://example.com`, while avoiding the
overhead associated with large response headers, and the uncertainty that
they've really covered everything that lives on the origin.

When they see a request come in that contains a <a>`Origin-Policy`</a>
header, they can respond in kind, pointing the client to a manifest file
in a well-known location on their server. That is, given the following
request:

<pre>
GET / HTTP/1.1
Host: example.com
Connection: keep-alive
...
<a>Origin-Policy</a>: 0
...
</pre>

MegaCorp, Inc. can respond with:

<pre>
HTTP/1.1 200 OK
Content-Encoding: gzip
Accept-Ranges: bytes
Cache-Control: max-age=604800
Content-Type: text/html
...
<a>Origin-Policy</a>: "policy-1"
...
</pre>

The client will parse the response headers, and synchronously request
`https://example.com/.well-known/origin-policy/v1` before completing
the navigation. The policies contained in that file will be cached
according to the normal HTTP caching rules, and applied to pages on
`https://example.com/` (including the current navigation).

<pre>
{
  "<a>csp</a>": [
    {
      "policy": "script-src 'self' https://cdn.example.com; object-src 'none'",
      "mode": "enforce",
      "type": "fallback"
    },
    {
      "policy": "script-src https:; report-to 'mixed'",
      "mode": "report",
      "type": "baseline"
    }
  ],
  "<a>referrer</a>": {
      "policy": "origin-when-cross-origin",
      "type": "fallback"
  },
  "<a>cors</a>": { "allow-credentials": true },
  "<a>nosniff</a>": true,
  "<a>hsts</a>": "max-age=10886400; includeSubDomains; preload",
}
</pre>

Subsequent requests from the same client will contain the version of
the policy currently cached for the origin. In this case:

<pre>
GET / HTTP/1.1
Host: example.com
Connection: keep-alive
...
<a>Origin-Policy</a>: "<strong>policy-1</strong>"
...
</pre>

Note: MegaCorp, Inc. can signficantly speed up this interaction by proactively
pushing the current manifest down to the client along with the initial response.
See [[#server-push]] for details.

ISSUE: Maybe turn this into a `Link` header with special behavior?
</div>

<div class="example">
MegaCorp, Inc. wishes to update the origin policy it has distributed to clients.
It can do so by setting an appropriate `Origin-Policy` header in the response.
That is, given the following request:

<pre>
GET / HTTP/1.1
Host: example.com
Connection: keep-alive
...
<a>Origin-Policy</a>: "<strong>policy-1</strong>"
...
</pre>

MegaCorp, Inc. can respond with:

<pre>
HTTP/1.1 200 OK
Content-Encoding: gzip
Accept-Ranges: bytes
Cache-Control: max-age=604800
Content-Type: text/html
...
<a>Origin-Policy</a>: "policy-2"
...
</pre>

The client will process the header, download and process the `policy-2` manifest,
and apply it to the response.
</div>

<div class="example">
MegaCorp, Inc. wishes to remove the origin policy it has distributed to clients.
It can do so by setting an `Origin-Policy` header with a value of `0` in the
response:

<pre>
HTTP/1.1 200 OK
Content-Encoding: gzip
Accept-Ranges: bytes
Cache-Control: max-age=604800
Content-Type: text/html
...
<a>Origin-Policy</a>: 0
...
</pre>

The client will process the header, and evict any origin policy for the
response's origin.

Note: The manifest itself will be removed, but some of the policies it set may
still be effective. For example, if the <a>`hsts`</a> member was set, the
`maxage` property it contained may still force TLS on any connection to the
origin's host. Those kinds of behaviors will need to be cleared individually,
as appropriate for the feature. For example, to remove HSTS, the server could
send `Strict-Transport-Security: maxage=0`.
</div>

Framework {#framework}
======================

Concepts {#concepts}
--------

An <dfn>origin policy object</dfn> is a tuple of a string
(<dfn for="origin policy object">version</dfn>), and the contents of an
<a>origin policy manifest</a> (<dfn for="origin policy object">body</dfn>).

User agents have a <dfn export>Origin Policy Store</dfn>, which is a key
value store mapping <a>origin policy objects</a> to <a>origins</a>.

When asked to <dfn algorithm local-lt="get-policy-from-store">retrieve an Origin
Policy for an origin</dfn>, an <a>Origin Policy Store</a> will return either a
single <a>origin policy object</a> (if one is stored for the given origin), or
`null` (if nothing is stored for the given origin).

When asked to <dfn algorithm local-lt="evict-policy-from-store">evict an Origin
policy for an origin</dfn>, an <a>Origin Policy Store</a> will discard any
<a>origin policy object</a> associated with the given origin.

The `Origin-Policy` HTTP Header Field {#origin-policy-header}
-----------------------------------------------------------------

The <dfn export>`Origin-Policy`</dfn> HTTP header field is sent with
navigational HTTP requests in order to advertise support generally for the
origin policy manifest mechanism defined in this document, and to inform
the server which version of its origin policy is cached locally.

The same header is sent by the server in responses to such requests to
inform the client that a origin policy manifest is available to fetch. Its
value MUST be either `0` or a base64-encoded value, wrapped in double-quotes.
The following ABNF defines that more formally:

<pre class="abnf" dfn-type="grammar" link-type="grammar">
  Origin-Policy: 0 / <a>manifest-name</a>
  <dfn>manifest-name</dfn>: <a>DQUOTE</a> <a>base64-value</a> <a>DQUOTE</a>
  ; base64-value is defined in [[!CSP3]]
  ; DQUOTE is defined in [[!RFC5234]]
</pre>

This header MUST be ignored if delivered over non-secure transport.

The Origin Policy Manifest File {#manifest-file}
------------------------------------------------------

The <dfn export local-lt="manifest">Origin Policy Manifest</dfn> is a
JSON-formatted document consisting of a top-level object with one or more
members. Each member defines a specific aspect of an origin's policy.

<pre class="example">
{
  "<a>csp</a>": [
    {
      "policy": "script-src 'self' https://cdn.example.com; object-src 'none'",
      "mode": "enforce",
      "type": "fallback"
    },
    {
      "policy": "script-src https:; report-to 'mixed'",
      "mode": "report",
      "type": "baseline"
    }
  ],
  "<a>referrer</a>": {
      "policy": "origin-when-cross-origin",
      "type": "fallback"
  },
  "<a>cors</a>": { "allow-credentials": true },
  "<a>nosniff</a>": true,
  "<a>hsts</a>": true,
}
</pre>

ISSUE: Perhaps the various members should be pushed out into various other
specs in some kind of extension model. That is, the parsing algorithm could
have a hook for the member name that other specs could latch onto. Not sure
if that's worth the effort, but it might be a more rational way to define
behavior, since we're otherwise hooking into a different spec for each bit.

### The `origin-policy` well-known location ### {#origin-policy-well-known}

<a>Origin Policy Manifest</a> files for a given origin MUST be located as
suffixes to the well-known location `/.well-known/origin-policy` [[RFC5785]].
Their names MUST be double-quoted strings of characters matching the
<a grammar>base64-value</a> grammar. That is, `/.well-known/origin-policy/a`
might point to one <a>Origin Policy Manifest</a> file, while
`/.well-known/origin-policy/b` might point to another.

Servers MUST respond to a `GET` request to `/.well-known/origin-policy` with a
302 redirect whose `Location` header points to the origin's current <a>Origin
Policy Manifest</a>, or with a 404 response if no such policy is available.

Note: This redirect can be used as a discovery mechanism. User agents might
prefetch such manifest files for origins a user is likely to visit, testing
services might give developers automated feedback on their origin's manifest,
etc.

### The `csp` member ### {#csp-member}

The <dfn export>`csp`</dfn> member defines a set of <a>Content Security
Policies</a> [[!CSP3]] which will be applied to every resource delivered from the
manifest's origin.

Its value MUST be either a single dictionary, or a list of dictionaries. Each
dictionary MUST have a "`policy`" member, and MAY have "`mode`" and "`type`"
members.

:   <dfn export for="csp">policy</dfn>
::  The CSP to be applied.
:   <dfn export for="csp">mode</dfn>
::  "`enforce`" or "`report`". If not specified, "`enforce`".
:   <dfn export for="csp">type</dfn>
::  "`baseline`" or "`fallback`". If the former, the given `policy` will be
    applied to every resource on an origin. If the latter, the given `policy`
    will be applied only to the resources on an origin that don't themselves
    deliver a `Content-Security-Policy` or `Content-Security-Policy-Report-Only`
    header (as appropriate for the `mode`).

### The `referrer` member ### {#referrer-member}

The <dfn export>`referrer`</dfn> member defines a <a>Referrer Policy</a>
[[!REFERRER-POLICY]] which will be applied to every resource delivered from
the policy's origin.

Its value MUST be a single dictionary with a "`policy`" member, and an optional
"`type`" member.

:   <dfn export for="referrer">policy</dfn>
::  The Referrer Policy to be applied.
:   <dfn export for="referrer">type</dfn>
::  "`baseline`" or "`fallback`". If the former, the given `policy` will be
    applied to every resource on an origin. If the latter, the given `policy`
    will be applied only to the resources on an origin that don't themselves
    deliver a `Referrer-Policy` header.

### The `cors-preflight` member ### {#cors-preflight-member}

The <dfn export>`cors`</dfn> member asserts that an origin understands the
CORS protocol, and that the user agent can therefore assume success for certain
types of <a>CORS-preflight requests</a>.

Note: This member does <em>not</em> set defaults for responses in general; it
only allows the user agent to skip the `OPTIONS` preflight request for a
defined set of requests.

Its value MUST be a dictionary. Any other type will be ignored.

#### Values #### {#cors-preflight-values}

ISSUE: Spell this out.

<pre class="example">
  {
    "cors-preflight": {
      "allow-credentials": true,
      "allow-headers": [ "x-application-specific-header" ],
      "allow-origin": [ "https://not-example.com/" ]
    }
  }
</pre>

ISSUE: This might be a footgun?

### The `hsts` member ### {#hsts-member}

The <dfn export>`hsts`</dfn> member asserts Strict Transport Security for an
origin [[!RFC6797]].

### The `hpkp` member ### {#hpkp-member}

The <dfn export>`hpkp`</dfn> member asserts a set of pinned public keys for an
origin [[!RFC7469]].

### The `nosniff` member ### {#nosniff-member}

The <dfn export>`nosniff`</dfn> member asserts that resources served from an
origin should rely only on their explicitly asserted `Content-Type`, and MUST
not be sniffed into other types of content based on their contents.

Algorithms {#algorithms}
==========

<h3 algorithm dfn id="version-for-origin">
  Retrieve |origin|'s manifest version.
</h3>

Given an origin (|origin|), this algorithm returns `0` if no manifest is present
in the user agent's <a>Origin Policy Store</a>, or a string representing the
cached version otherwise.

1.  Let |version| be `0`.

2.  If the user agent's <a>Origin Policy Store</a> contains a tuple for
    |origin|, let |version| be that tuple's first element.

3.  Return |version|.

<h3 algorithm dfn id="evict-for-origin">
  Evict |origin|'s cached manifest.
</h3>

Given an origin (|origin|), this algorithm removes any cached manifest from the
user agent's <a>Origin Policy Store</a>:

1.  Instruct the user agent's <a>Origin Policy Store</a> to
    <a lt="evict-policy-from-store">evict</a> any <a>Origin Policy object</a>
    stored for |origin|.

HTML Integration {#monkey-patching-html}
----------------

At the end of the navigation algorithm, we'll do the following:

1.  If we have a policy for the origin to which we've navigated (or we're inheriting the
    origin for an `about:blank` or `about:srcdoc` (or if we're Firefox, `data:...`),
    then we apply the policy to the document as defined in [[#html-apply-policy]] (which
    I haven't written yet.

At the end of the "run a worker" algorithm, we'll do the same thing.

<h4 algorithm dfn id="html-apply-policy">
  Apply Origin Policy to |settings|.
</h4>

ISSUE: Write this algorithm.

Fetch Integration {#monkey-patching-fetch}
-----------------

During a navigation request, Fetch will hook into this specification in two ways:

1.  At the top of the basic fetch algorithm, Fetch will call
    [[#fetch-prepare-request]] in order to append `Origin-Policy` to the
    request's header list with a value of `0` if no manifest is cached for its
    URL's origin, or a value of the verion of the manifest that is cached  (e.g.
    `"v1"`).

2.  When a response is received during HTTP-network fetch algorithm, Fetch will
    call into [[#fetch-parse-response]] to sift through its headers, and
    extract the `Origin-Policy` header. If present, and its value does not match
    the value of the locally cached manifest for the response's origin, we'll issue
    a synchronous request for a resource located on the request's URL's origin at
    `/.well-known/origin-policy/{value}`, as defined in [[#fetch-manifest]].

    ISSUE: Should we allow service workers to intercept/set policy? Maybe only if they
    are scoped to the whole origin?

3.  Directly after Fetch calls into [[#fetch-parse-response]], it will call into
    [[#fetch-apply-policy]] to apply any cached policy to the response.

<h4 algorithm dfn id="fetch-prepare-request">
  Prepare |request| with Origin Policy.
</h4>

Given a request |request|, add appropriate headers to inform a server about a
client's active policy:

1.  If |request| is not a navigation request, or if  abort these steps and return.

2.  Let |version| be the result of executing [[#version-for-origin]] on
    |request|'s URL's origin.

3.  Append a header named `Origin-Policy` with a value of |version| to
    |request|'s header list.

<h4 algorithm dfn id="fetch-parse-response">
  Process |response| for Origin Policy.  
</h4>

1.  Let |version| be the result of parsing "`Origin-Policy`" in |response|'s
    header list.

2.  If |version| is not `null`, execute [[#fetch-manifest]] on |version| and
    |response|'s URL's origin.

<h4 algorithm dfn id="fetch-manifest">
  Fetch an Origin Policy manifest |version| for |origin|.
</h4>

To fetch a origin policy manifest given a string (|version|) and an origin
(|origin|) execute the following steps. If |version| is `0`, any policy cached
for |origin| will be evicted. Otherwise, if |version| is a valid name, the
manifest it points to will be retrieved and cached locally:

1.  If |origin| is an opaque origin, abort these steps and return.

2.  Let |url| be the result of executing the <a>URL parser</a> on |origin|'s
    serialization.

3.  If |url| is failure, or [[secure-contexts#is-url-trustworthy]] returns
    "`Not Trustworthy`" when executed upon |url|, abort these steps and return.

4.  If |version| is `0`, the user agent MUST execute [[#evict-for-origin]]
    upon |origin|, abort these steps and return.

5.  If |version| does not match the <a grammar>manifest-name</a> grammar, abort
    these steps and return.

6.  Set |url|'s path to the concatenation of "`/.well-known/origin-policy/`" and
    |version|.

7.  Let |request| be a new request whose method is "`GET`", url is |url|, client
    is `null`, window is `no-window`, skip-service-worker flag is set,
    destination is `manifest`, mode is `same-origin`, and redirect mode is
    `error`.

8.  Let |response| be the result of performing an HTTP-network-or-cache fetch 
    using |request|.

9.  If |response|'s status is an ok status:

    1.  Let |MIME type| be the result of extracting a MIME type from
        |response|'s header list.

    2.  If |MIME type| is not `application/manifest+json`, abort these steps
        and return.

    3.  Store the tuple (|version|, |response|'s body) in the user agent's
        <a>Origin Policy Store</a> for |origin|.

<h4 algorithm dfn id="fetch-apply-policy">
  Apply an Origin Policy to |response|.
</h4>

Given a response (|response|), the following algorithm applies the relevant
<a>origin policy object</a>:

1.  Let |origin| be |response|'s URL's origin.

2.  If |origin| is an opaque origin, or if
    [[secure-contexts#is-origin-trustworthy]] returns "`Not Trustworthy`" when
    executed upon |origin|, abort these steps and return.

3.  Let |object| be the result of instructing the user agent's <a>Origin Policy
    Store</a> to <a lt="get-policy-from-store">retrieve an Origin Policy
    object</a> for |origin|.

4.  If |object| is `null`, abort these steps and return.

5.  Set |policy| to |object|'s <a for="origin policy object">body</a>.

6.  For each member (|member|) in |policy|, execute the steps associated with
    the matching statement below:

    :   <a>`csp`</a>
    ::  1.  If |member|'s value is not valid, abort these steps and return.

            ISSUE: Spell this out. JSON schema? It must be a list of dictionaries
            with `policy` members. `mode` and `type` members may also be present.

        2.  For each |item| in |member|'s value:

            1.  Let |policy| be |item|'s `policy` member's value; |mode|
                be |item|'s `mode` member's value if present, and "`enforce`"
                otherwise; and |type| be |item|'s `type` member's value if
                present, and "`baseline`" otherwise.

            2.  Let |header name| be "`Content-Security-Policy`" if |mode| is
                "`enforce`", and "`Content-Security-Policy-Report-Only`"
                otherwise.

            3.  If |type| is "`fallback`", and the result of
                <a for="header list">parsing</a> |header name| in
                |response|'s <a for="response">header list</a> is not `null`,
                skip the remaining substep, and proceed to the next |item|.

            4.  Append each policy in the result of executing
                [[csp3#parse-serialized-policy-list]] on |policy| with a
                disposition of |mode| to |response|'s
                <a for="response">CSP list</a> [[!CSP3]].
    :   <a>`hsts`</a>
    ::  1.  If |member|'s value is not `false`, append a header named
            "`Strict-Transport-Security`" with a value of |member|'s value to
            |response|'s <a for="response">header list</a> [[!RFC6797]].
    :   <a>`hpkp`</a>
    ::  1.  If |member|'s value is not `false`, append a header named
            "`Public-Key-Pins`" with a value of |member|'s value to
            |response|'s <a for="response">header list</a> [[!RFC7469]].

            ISSUE: We should somehow support `report-only`. Probably same
            syntax as CSP?
    :   <a>`nosniff`</a>
    ::  1.  If |member|'s value is not `false`, append a header named
            "`X-Content-Type-Options`" with a value of "`nosniff`" to
            |response|'s <a for="response">header list</a> [[!FETCH]].
    :   <a>`referrer`</a>
    ::  1.  If |member|'s value is not valid, abort these steps and return.

            ISSUE: Spell this out. JSON schema? It must be a list of dictionaries
            with `policy` members. `mode` and `type` members may also be present.

        2.  Let |policy| be |member|'s value's `policy` member's value, and
            |type| be |member"'s value's `type` member's value if present,
            and "`baseline`" otherwise.

        3.  If |type| is "`fallback`", and the result of
            <a for="header list">parsing</a> "`Referrer-Policy`" in
            |response|'s <a for="response">header list</a> is not `null`,
            skip the remaining substep, and proceed to the next |item|.

        3.  Append each policy in the result of executing
            [[referrer-policy#set-requests-referrer-policy-on-redirect]] on
            |response| and |policy| [[!REFERRER-POLICY]].


Specification Considerations {#specification}
=============================

Relation to Web App Manifests {#app-manifest}
-----------------------------

It might make sense to combine this mechanism with the manifest notion
defined in [[APPMANIFEST]]. There are a few distinctions, however, which
lead to the current design:

1.  The =Security Policy Manifest= is delivered synchronously during navigation,
    which gives it a number of valuable security properties. The web app
    manifest, on the other hand, is delivered inline via a <{link}> element,
    which makes it less valuable from that perspective.

2.  Web app manifests can live anywhere on an origin, and anywhere on any other
    origin, for that matter. This might make sense for the feature set it wishes
    to expose, but it would expose an origin to unnecessary risk to be quite so
    loose with =security policy manifest= files.

Nevertheless, we should consider ways to merge this policy with [[APPMANIFEST]].
Perhaps if a certain set of attributes was parsed iff certain properties of the
request are true (same-origin, specific path, etc). Something to look into. For
now, we've done the simple thing as a strawman.

Why `.well-known`? {#why-well-known}
------------------

This document forces the manifest to live as a resource accessible under a
"well-known location" specific to Origin Policy manifests. It would increase
flexibility of deployment and implementation if we allowed a developer to point
to any location on an origin instead. Perhaps something like the following:

```
  Origin-Policy: /path/to/manifest.json
```

This would allow developers who control an application, but not the server on
which the application runs, to define policy for themselves without bothering
the sysadmins and filing internal tickets to get a `.well-known` directory
created, populated, and mapped to something externally accessible.

So why does this document force a well-known location?

In short, this document posits that setting a policy for an origin is an action
that should, in fact, involve the folks responsible for running the origin's
server, as it has cross-cutting effects upon <em>every</em> application hosted
on an origin. Unlike a response-specific `Content-Security-Policy` header, the
<a>`csp`</a> member can apply a baseline policy to <em>all</em> the responses an
origin emits. This can be hugely benificial, but also hugely destructive.

Consider, for example, MegaCorp, Inc.'s `https://example.com`, which
hosts a mail application, a mapping application, a document editing application,
and so on. It would be unfortunate indeed if one of these applications
accidentally pinned a policy to the entire origin which didn't account for the
rest of the origin's contents. To mitigate that risk, this document forces the
manifest to live in a shared location for an origin. The goal is explicitly to
eilicit the kind of discussion and compromise within an origin that needs to
happen in order to deploy an Origin Policy safely.

Authoring Considerations {#authoring}
========================

Performance {#perf}
-----------

Servers SHOULD set a long cache lifetime for the manifest file, using the version
to change policy for an origin as opposed to changing the existing policy and
relying on cache expiration.

Server Push {#server-push}
-----------

To speed up the initial, synchronous request for the manifest file, servers
SHOULD use the <a>Server Push</a> mechanism defined in [[RFC7540]] to get the
manifest down to the client as quickly as possible.

1.  Send a `PUSH_PROMISE` frame with a minimal request for the manifest,
    aligning with the request generated in [[#fetch-manifest]].

2.  Begin delivering the response to the `PUSH_PROMISE` request.

ISSUE: Spell this out with an example.

CSP: Nonces and `'strict-dynamic'` {#strict-dynamic}
----------------------------------

Content Security Policy has introduced some dynamic mechanisms that are quite
valuable in terms of encouraging deployment. Nonces, along with the
<a grammar>`'strict-dynamic'`</a> expression are a good example of an
implementation which requires a server to send a fresh value down with each
response. Origin Policy can support such deployments via the "`fallback`"
mechanism as follows:

<div class="example">
MegaCorp, Inc. wishes to deploy a strong Content Security Policy which blocks
plugins and framing altogether, but which uses `'strict-dynamic'` along with a
fresh nonce for each resource in order to reduce the risk of cross-site
scripting. It can do so by combining a "`baseline`" and "`fallback`" policy in
the <a>Origin Policy Manifest</a>, and delivering a `Content-Security-Policy`
header along with each response.

That is, the manifest file might contain the following JSON:

<pre>
{
  ...
  "<a>csp</a>": [
    {
      "<a for="csp">policy</a>": "script-src 'none'",
      "<a for="csp">type</a>": "fallback"
    },
    {
      "<a for="csp">policy</a>": "object-src 'none'; frame-ancestors 'self'",
      "<a for="csp">type</a>": "baseline"
    }
  ],
  ...
}
</pre>

And each resource's response might contain the following header:

<pre>
  <a>Content-Security-Policy</a>: script-src 'nonce-{nonce-goes-here}' 'strict-dynamic'
</pre>

The baseline policy will be applied to every response, blocking plugins and
restricting framing regardless of the response's other headers.

The fallback policy will be applied iff the response doesn't itself provide a
Content Security Policy, meaning that the resource's policy will be applied,
the nonce will be active, and script will execute as expected.
</div>

Privacy and Security Considerations {#privacy-and-security}
===================================

Tracking {#tracking}
--------

The <a>`Origin-Policy`</a> header, as well as the manifest it represents, can
be used to track users with only marginally less granularity and coverage than
cookies allow. As such, the user agent MUST purge cached manifests whenever a
user instructs it to clear cookies or cached data.

IANA Considerations {#iana}
===================

The `Origin-Policy` header {#iana-header}
--------------------------

The permanent message header field registry should be updated
with the following registration: [[!RFC3864]]

:   Header field name
::  `Origin-Policy`
:   Applicable protocol
::  http
:   Status
::  WIP
:   Author/Change controller
::  W3C
:   Specification document
::  This specification (see [[#origin-policy-header]])

Creation of the well-known location `origin-policy` {#iana-well-known}
---------------------------------------------------

This document defines a well-known location at which <a>Origin Policy
manifests</a> may be found. In accordance with [[RFC5758]], the following
registration should be made if and when the proposal in this document gains
acceptance and implementation:

:   URI Suffix
::  `origin-policy`
:   Change Controller
::  W3C
:   Specification document
::  This document (see [[#origin-policy-well-known]])
:   Related information
::  The suffix `origin-policy` is expected to be followed by an additional path
    component which names a specific <a>Origin Policy manifest</a> (e.g.
    `/.well-known/origin-policy/name`). A request to
    `/.well-known/origin-policy` can be expected to redirect to the most current
    policy for an origin.

Acknowledgements {#ack}
================

Mark Nottingham came up with more or less the same idea at more or less the
same time (after waiting ~years for me to write this up) [[SITE-WIDE-HEADERS]].
I've swiped large swaths of his introduction, as it's better than what I was
coming up with.
