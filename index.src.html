<pre class='metadata'>
Title: Origin Policy Manifest
Status: DREAM
ED: https://mikewest.github.io/origin-policy-manifest/
Shortname: origin-policy
Level: None
Editor: Mike West 56384, Google Inc., mkwst@google.com
Abstract:
  This specification defines a delivery mechanism for a number of policies
  which are to be applied to an entire origin. It compliments header-based
  delivery mechanisms for existing policies (Content Security Policy,
  Referrer Policy, etc).
Indent: 2
Markup Shorthands: markdown on
Boilerplate: omit conformance, omit feedback-header
</pre>
<pre class="link-defaults">
spec:html; type:element; text:link
</pre>
<pre class="anchors">
spec: FETCH; urlPrefix: https://fetch.spec.whatwg.org/
  type: dfn
    text: CORS-preflight request
<!--
   -   ABNF
   -->
type: grammar
  text: base64-value; url: https://w3c.github.io/webappsec-csp/#grammardef-base64-value; spec: CSP3
  text: DQUOTE; url: https://tools.ietf.org/html/rfc5234#appendix-B.1; spec: RFC5234
</pre>

Introduction {#intro}
=====================

[Insert clever introduction here.]

Examples {#examples}
--------------------

<div class="example">
MegaCorp, Inc. wishes to ensure that a baseline content security policy is
applied to each of the pages on `https://example.com`, while avoiding the
overhead associated with large response headers, and the uncertainty that
they've really covered everything that lives on the origin.

When they see a request come in that contains a <a>`Origin-Policy`</a>
header, they can respond in kind, pointing the client to a manifest file
in a well-known location on their server. That is, given the following
request:

<pre>
GET / HTTP/1.1
Host: example.com
Connection: keep-alive
...
<a>Origin-Policy</a>: 0
...
</pre>

MegaCorp, Inc. can respond with:

<pre>
HTTP/1.1 200 OK
Content-Encoding: gzip
Accept-Ranges: bytes
Cache-Control: max-age=604800
Content-Type: text/html
...
<a>Origin-Policy</a>: "v1"
...
</pre>

The client will parse the response headers, and synchronously request
`https://example.com/.well-known/origin-policy/v1` before completing
the navigation. The policies contained in that file will be cached
according to the normal HTTP caching rules, and applied to pages on
`https://example.com/` (including the current navigation).

<pre>
{
  "<a>csp</a>": [
    {
      "policy": "script-src 'self' https://cdn.example.com; object-src 'none'",
      "mode": "enforce",
      "type": "fallback"
    },
    {
      "policy": "script-src https:; report-to 'mixed'",
      "mode": "report",
      "type": "baseline"
    }
  ],
  "<a>referrer</a>": "origin-when-cross-origin",
  "<a>cors</a>": { "allow-credentials": true },
  "<a>nosniff</a>": true,
  "<a>hsts</a>": true,
}
</pre>

Subsequent requests from the same client will contain the version of
the policy currently cached for the origin. In this case:

<pre>
GET / HTTP/1.1
Host: example.com
Connection: keep-alive
...
<a>Origin-Policy</a>: "<strong>v1</strong>"
...
</pre>

ISSUE: Maybe turn this into a `Link` header with special behavior?
</div>

<pre class="example">
[Add an HTTP/2 server push example to speed this up.]
</pre>

Framework {#framework}
======================

Concepts {#concepts}
--------

An <dfn>origin policy object</dfn> is a tuple of a string
(<dfn for="policy">version</dfn>), and the contents of an
<a>origin policy manifest</a>.

User agents have a <dfn export>Origin Policy Store</dfn>, which is a key
value store mapping <a>origin policy objects</a> to <a>origins</a>.

When asked to <dfn algorithm>retrieve an Origin Policy for an origin</dfn>,
an <a>Origin Policy Store</a> will return either a single <a>origin policy
object</a> (if one is stored for the given origin), or `null` (if nothing is
stored for the given origin).

The `Origin-Policy` HTTP Header Field {#origin-policy-header}
-----------------------------------------------------------------

The <dfn export>`Origin-Policy`</dfn> HTTP header field is sent with
navigational HTTP requests in order to advertise support generally for the
origin policy manifest mechanism defined in this document, and to inform
the server which version of its origin policy is cached locally.

The same header is sent by the server in responses to such requests to
inform the client that a origin policy manifest is available to fetch. Its
value MUST be either `0` or a base64-encoded value, wrapped in double-quotes.
The following ABNF defines that more formally:

<pre class="abnf" dfn-type="grammar" link-type="grammar">
  Origin-Policy: 0 / <a>manifest-name</a>
  <dfn>manifest-name</dfn>: <a>DQUOTE</a> <a>base64-value</a> <a>DQUOTE</a>
  ; base64-value is defined in [[!CSP3]]
  ; DQUOTE is defined in [[!RFC5234]]
</pre>

This header MUST be ignored if delivered over non-secure transport.

The Origin Policy Manifest File {#manifest-file}
------------------------------------------------------

The <dfn export local-lt="manifest">Origin Policy Manifest</dfn> is a
JSON-formatted document consisting of a top-level object with one or more
members. Each member defines a specific aspect of an origin's policy.

<pre class="example">
{
  "<a>csp</a>": [
    {
      "policy": "script-src 'self' https://cdn.example.com; object-src 'none'",
      "mode": "enforce",
      "type": "fallback"
    },
    {
      "policy": "script-src https:; report-to 'mixed'",
      "mode": "report",
      "type": "baseline"
    }
  ],
  "<a>referrer</a>": "origin-when-cross-origin",
  "<a>cors</a>": { "allow-credentials": true },
  "<a>nosniff</a>": true,
  "<a>hsts</a>": true,
}
</pre>

ISSUE: Perhaps the various members should be pushed out into various other
specs in some kind of extension model. That is, the parsing algorithm could
have a hook for the member name that other specs could latch onto. Not sure
if that's worth the effort, but it might be a more rational way to define
behavior, since we're otherwise hooking into a different spec for each bit.

### The `origin-policy` well-known location {#origin-policy-well-known}

<a>Origin Policy Manifest</a> files for a given origin MUST be located as
suffixes to the well-known location `/.well-known/origin-policy` [[RFC5785]].
Their names MUST be double-quoted strings of characters matching the
<a grammar>base64-value</a> grammar. That is, `/.well-known/origin-policy/a`
might point to one <a>Origin Policy Manifest</a> file, while
`/.well-known/origin-policy/b` might point to another.

Servers MUST respond to a `GET` request to `/.well-known/origin-policy` with a
302 redirect whose `Location` header points to the origin's current <a>Origin
Policy Manifest</a>, or with a 404 response if no such policy is available.

Note: This redirect can be used as a discovery mechanism. User agents might
prefetch such manifest files for origins a user is likely to visit, testing
services might give developers automated feedback on their origin's manifest,
etc.

### The `csp` member {#csp-member}

The <dfn export>`csp`</dfn> member defines a set of <a>Content Security
Policies</a> [[!CSP3]] which will be applied to every resource delivered from the
manifest's origin.

Its value MUST be either a single dictionary, or a list of dictionaries. Each
dictionary MUST have a "`policy`" member, and MAY have "`mode`" and "`type`"
members.

:   <dfn export for="csp">policy</dfn>
::  The CSP to be applied.
:   <dfn export for="csp">mode</dfn>
::  "`enforce`" or "`report`". If not specified, "`enforce`".
:   <dfn export for="csp">type</dfn>
::  "`baseline`" or "`fallback`". If the former, the given `policy` will be
    applied to every resource on an origin. If the latter, the given `policy`
    will be applied only to the resources on an origin that don't themselves
    deliver a `Content-Security-Policy` or `Content-Security-Policy-Report-Only`
    header (as appropriate for the `mode`).

Any non-conforming value will be ignored.

### The `referrer` member {#referrer-member}

The <dfn export>`referrer`</dfn> member defines a <a>Referrer Policy</a>
[[!REFERRER-POLICY]] which will be applied to every resource delivered from
the policy's origin.

Its value MUST be a string. Any other type will be ignored.

### The `cors-preflight` member {#cors-preflight-member}

The <dfn export>`cors`</dfn> member asserts that an origin understands the
CORS protocol, and that the user agent can therefore assume success for certain
types of <a>CORS-preflight requests</a>.

Note: This member does <em>not</em> set defaults for responses in general; it
only allows the user agent to skip the `OPTIONS` preflight request for a
defined set of requests.

Its value MUST be a dictionary. Any other type will be ignored.

#### Values {#cors-preflight-values}

ISSUE: Spell this out.

<pre class="example">
  {
    "cors-preflight": {
      "allow-credentials": true,
      "allow-headers": [ "x-application-specific-header" ],
      "allow-origin": [ "https://not-example.com/" ]
    }
  }
</pre>

ISSUE: This might be a footgun?

### The `hsts` member {#hsts-member}

The <dfn export>`hsts`</dfn> member asserts Strict Transport Security for an
origin [[!RFC6797]].

### The `hpkp` member {#hpkp-member}

The <dfn export>`hpkp`</dfn> member asserts a set of pinned public keys for an
origin [[!RFC7469]].

### The `nosniff` member {#nosniff-member}

The <dfn export>`nosniff`</dfn> member asserts that resources served from an
origin should rely only on their explicitly asserted `Content-Type`, and MUST
not be sniffed into other types of content based on their contents.


HTML Integration {#monkey-patching-html}
----------------

At the end of the navigation algorithm, we'll do the following:

1.  If we have a policy for the origin to which we've navigated (or we're inheriting the
    origin for an `about:blank` or `about:srcdoc` (or if we're Firefox, `data:...`),
    then we apply the policy to the document as defined in [[#apply-policy]] (which
    I haven't written yet.

At the end of the "run a worker" algorithm, we'll do the same thing.

ISSUE: Spell all of this out.

Algorithms {#algorithms}
==========

<h3 algorithm dfn id="version-for-origin">
  Retrieve |origin|'s manifest version.
</h3>

Given an origin (|origin|), this algorithm returns `0` if no manifest is present
in the user agent's <a>Origin Policy Store</a>, or a string representing the
cached version otherwise.

1.  Let |version| be `0`.

2.  If the user agent's <a>Origin Policy Store</a> contains a tuple for
    |origin|, let |version| be that tuple's first element.

3.  Return |version|.

Fetch Integration {#monkey-patching-fetch}
-----------------

During a navigation request, Fetch will hook into this specification in two ways:

1.  At the top of the basic fetch algorithm, Fetch will call
    [[#fetch-prepare-request]] in order to append `Origin-Policy` to the
    request's header list with a value of `0` if no manifest is cached for its
    URL's origin, or a value of the verion of the manifest that is cached  (e.g.
    `"v1"`).

2.  When a response is received during HTTP-network fetch algorithm, Fetch will
    call into [[#fetch-parse-response]] to sift through its headers, and
    extract the `Origin-Policy` header. If present, and its value does not match
    the value of the locally cached manifest for the response's origin, we'll issue
    a synchronous request for a resource located on the request's URL's origin at
    `/.well-known/origin-policy/{value}`, as defined in [[#fetch-manifest]].

    ISSUE: Should we allow service workers to intercept/set policy? Maybe only if they
    are scoped to the whole origin?

<h4 algorithm dfn id="fetch-prepare-request">
  Prepare |request| with Origin Policy.
</h4>

Given a request |request|, add appropriate headers to inform a server about a
client's active policy:

1.  If |request| is not a navigation request, or if  abort these steps and return.

2.  Let |version| be the result of executing [[#version-for-origin]] on
    |request|'s URL's origin.

3.  Append a header named `Origin-Policy` with a value of |version| to
    |request|'s header list.

<h4 algorithm dfn id="fetch-parse-response">
  Process |response| for Origin Policy.  
</h4>

1.  Let |version| be the result of parsing "`Origin-Policy`" in |response|'s
    header list.

2.  If |version| is not `null`, execute [[#fetch-manifest]] on |version| and
    |response|'s URL's origin.

<h4 algorithm dfn id="fetch-manifest">
  Fetch an Origin Policy manifest |version| for |origin|.
</h4>

To fetch a origin policy manifest given a string (|version|) and an origin
(|origin|) execute the following steps:

1.  If |origin| is an opaque origin, abort these steps and return.

2.  Let |url| be the result of executing the <a>URL parser</a> on |origin|'s
    serialization.

3.  If |url| is failure, or [[secure-contexts#is-url-trustworthy]] returns
    "`Not Trustworthy`" when executed upon |url|, abort these steps and return.

4.  Set |url|'s path to the concatenation of "`/.well-known/origin-policy/`" and
    |version|.

5.  Let |request| be a new request whose method is "`GET`", url is |url|, client
    is `null`, window is `no-window`, skip-service-worker flag is set,
    destination is `manifest`, mode is `same-origin`, and redirect mode is
    `error`.

6.  Let |response| be the result of performing an HTTP-network-or-cache fetch 
    using |request|.

7.  If |response|'s status is an ok status:

    1.  Let |MIME type| be the result of extracting a MIME type from
        |response|'s header list.

    2.  If |MIME type| is not `application/manifest+json`, abort these steps
        and return.

    3.  Store the tuple (|version|, |response|'s body) in the user agent's
        <a>Origin Policy Store</a> for |origin|.


Specification Considerations {#specification}
=============================

Fallback vs Baseline {#fallback-vs-baseline}
--------------------

Perhaps this ought to be defined at a higher level of the manifest? It seems
like it might be a useful concept for things other than CSP.

Relation to Web App Manifests {#app-manifest}
-----------------------------

It might make sense to combine this mechanism with the manifest notion
defined in [[APPMANIFEST]]. There are a few distinctions, however, which
lead to the current design:

1.  The =Security Policy Manifest= is delivered synchronously during navigation,
    which gives it a number of valuable security properties. The web app
    manifest, on the other hand, is delivered inline via a <{link}> element,
    which makes it less valuable from that perspective.

2.  Web app manifests can live anywhere on an origin, and anywhere on any other
    origin, for that matter. This might make sense for the feature set it wishes
    to expose, but it would expose an origin to unnecessary risk to be quite so
    loose with =security policy manifest= files.

Nevertheless, we should consider ways to merge this policy with [[APPMANIFEST]].
Perhaps if a certain set of attributes was parsed iff certain properties of the
request are true (same-origin, specific path, etc). Something to look into. For
now, we've done the simple thing as a strawman.

Why `.well-known`? {#why-well-known}
------------------

This document forces the manifest to live as a resource accessible under a
"well-known location" specific to Origin Policy manifests. It would increase
flexibility of deployment and implementation if we allowed a developer to point
to any location on an origin instead. Perhaps something like the following:

```
  Origin-Policy: /path/to/manifest.json
```

This would allow developers who control an application, but not the server on
which the application runs, to define policy for themselves without bothering
the sysadmins and filing internal tickets to get a `.well-known` directory
created, populated, and mapped to something externally accessible.

So why does this document force a well-known location?

In short, this document posits that setting a policy for an origin is an action
that should, in fact, involve the folks responsible for running the origin's
server, as it has cross-cutting effects upon <em>every</em> application hosted
on an origin. Unlike a response-specific `Content-Security-Policy` header, the
<a>`csp`</a> member can apply a baseline policy to <em>all</em> the responses an
origin emits. This can be hugely benificial, but also hugely destructive.

Consider, for example, MegaCorp, Inc.'s `https://example.com`, which
hosts a mail application, a mapping application, a document editing application,
and so on. It would be unfortunate indeed if one of these applications
accidentally pinned a policy to the entire origin which didn't account for the
rest of the origin's contents. To mitigate that risk, this document forces the
manifest to live in a shared location for an origin. The goal is explicitly to
eilicit the kind of discussion and compromise within an origin that needs to
happen in order to deploy an Origin Policy safely.

Privacy and Security Considerations {#privacy-and-security}
===================================

Tracking {#tracking}
--------

The <a>`Origin-Policy`</a> header, as well as the manifest it represents, can
be used to track users with only marginally less granularity and coverage than
cookies allow. As such, the user agent MUST purge cached manifests whenever a
user instructs it to clear cookies or cached data.

Performance {#perf}
-----------

Servers SHOULD set a long cache lifetime for the manifest file, using the version
to change policy for an origin as opposed to changing the existing policy and
relying on cache expiration.

IANA Considerations {#iana}
===================

ISSUE: Register the header.

Creation of the well-known location `origin-policy` {#iana-well-known}
---------------------------------------------------

This document defines a well-known location at which <a>Origin Policy
manifests</a> may be found. In accordance with [[RFC5758]], the following
registration should be made if and when the proposal in this document gains
acceptance and implementation:

:   URI Suffix
::  `origin-policy`
:   Change Controller
::  W3C
:   Specification document
::  This document (see [[#origin-policy-well-known]])
:   Related information
::  The suffix `origin-policy` is expected to be followed by an additional path
    component which names a specific <a>Origin Policy manifest</a> (e.g.
    `/.well-known/origin-policy/name`). A request to
    `/.well-known/origin-policy` can be expected to redirect to the most current
    policy for an origin.
